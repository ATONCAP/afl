;; Agent Registry Contract
;; Manages registration of AI agents with SBT-based identities

#include "imports/stdlib.fc";

;; Storage layout:
;; admin_address: MsgAddress
;; next_agent_index: uint64
;; agent_identity_code: Cell (code for deploying Agent Identity SBTs)
;; content: Cell (collection metadata)

;; Op codes
const int op::register_agent = 0x1;
const int op::update_content = 0x2;
const int op::change_admin = 0x3;
const int op::upgrade_code = 0x4;

;; Error codes
const int error::unauthorized = 401;
const int error::invalid_message = 400;
const int error::insufficient_funds = 402;

;; Minimum fee for registration (0.1 TON)
const int min_registration_fee = 100000000;

;; Load contract data
(slice, int, cell, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),      ;; admin_address
        ds~load_uint(64),        ;; next_agent_index
        ds~load_ref(),           ;; agent_identity_code
        ds~load_ref()            ;; content
    );
}

;; Save contract data
() save_data(slice admin_address, int next_agent_index, cell agent_identity_code, cell content) impure inline {
    set_data(begin_cell()
        .store_slice(admin_address)
        .store_uint(next_agent_index, 64)
        .store_ref(agent_identity_code)
        .store_ref(content)
        .end_cell()
    );
}

;; Calculate Agent Identity SBT address
cell calculate_agent_identity_state_init(cell agent_identity_code, int agent_index, slice owner_address) inline {
    cell data = begin_cell()
        .store_uint(agent_index, 64)
        .store_slice(owner_address)
        .store_slice(my_address())  ;; registry address
        .store_ref(begin_cell().end_cell())  ;; empty content initially
        .store_uint(0, 1)  ;; revoked = false
        .end_cell();

    ;; StateInit structure: split_depth=0, special=0, code, data, library=empty
    return begin_cell()
        .store_uint(0, 2)           ;; split_depth and special (both 0)
        .store_uint(1, 1)           ;; code present = true
        .store_ref(agent_identity_code)
        .store_uint(1, 1)           ;; data present = true
        .store_ref(data)
        .store_uint(0, 1)           ;; library = empty
        .end_cell();
}

slice calculate_address(cell state_init) inline {
    return begin_cell()
        .store_uint(4, 3)
        .store_int(0, 8)  ;; workchain 0
        .store_uint(cell_hash(state_init), 256)
        .end_cell()
        .begin_parse();
}

;; Deploy new Agent Identity SBT
() deploy_agent_identity(int agent_index, slice owner_address, cell content, cell agent_identity_code, int msg_value) impure inline {
    cell state_init = calculate_agent_identity_state_init(agent_identity_code, agent_index, owner_address);
    slice agent_address = calculate_address(state_init);

    ;; Deploy message with init content
    cell deploy_msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(agent_address)
        .store_coins(msg_value - min_registration_fee / 2)  ;; Forward remaining minus some for gas
        .store_uint(4 + 2, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(state_init)
        .store_ref(content)  ;; Init message with content
        .end_cell();

    send_raw_message(deploy_msg, 1);  ;; Pay fees separately
}

;; Main entry point
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {  ;; Bounced message
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    (slice admin_address, int next_agent_index, cell agent_identity_code, cell content) = load_data();

    if (op == op::register_agent) {
        ;; Anyone can register an agent
        throw_unless(error::insufficient_funds, msg_value >= min_registration_fee);

        ;; Parse agent content from message
        cell agent_content = in_msg_body~load_ref();

        ;; Deploy the Agent Identity SBT
        deploy_agent_identity(next_agent_index, sender_address, agent_content, agent_identity_code, msg_value);

        ;; Increment agent index
        save_data(admin_address, next_agent_index + 1, agent_identity_code, content);
        return ();
    }

    if (op == op::update_content) {
        throw_unless(error::unauthorized, equal_slices(sender_address, admin_address));
        cell new_content = in_msg_body~load_ref();
        save_data(admin_address, next_agent_index, agent_identity_code, new_content);
        return ();
    }

    if (op == op::change_admin) {
        throw_unless(error::unauthorized, equal_slices(sender_address, admin_address));
        slice new_admin = in_msg_body~load_msg_addr();
        save_data(new_admin, next_agent_index, agent_identity_code, content);
        return ();
    }

    if (op == op::upgrade_code) {
        throw_unless(error::unauthorized, equal_slices(sender_address, admin_address));
        cell new_code = in_msg_body~load_ref();
        set_code(new_code);
        return ();
    }

    throw(error::invalid_message);
}

;; Get methods

;; Get registry data
(int, slice, cell) get_registry_data() method_id {
    (slice admin_address, int next_agent_index, cell agent_identity_code, cell content) = load_data();
    return (next_agent_index, admin_address, content);
}

;; Get agent address by owner
slice get_agent_address(int agent_index, slice owner_address) method_id {
    (_, _, cell agent_identity_code, _) = load_data();
    cell state_init = calculate_agent_identity_state_init(agent_identity_code, agent_index, owner_address);
    return calculate_address(state_init);
}

;; Get total registered agents
int get_total_agents() method_id {
    (_, int next_agent_index, _, _) = load_data();
    return next_agent_index;
}

;; Get collection content
cell get_content() method_id {
    (_, _, _, cell content) = load_data();
    return content;
}
